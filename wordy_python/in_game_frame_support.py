#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 7.6
#  in conjunction with Tcl version 8.6
#    May 20, 2023 05:27:58 PM CST  platform: Windows NT

import sys
import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *
from tkinter import messagebox as mb



import in_game_frame
import pending_game_frame
import pending_game_frame_support
import results_frame
import results_frame_support

import wordy_idl
from wordy_idl import *
import wordy_idl__POA
import CosNaming
import time

_debug = True # False to eliminate debug printing from callback functions.

game_servant = None
pending_time_remaining = 10

def update_pending_frame():
    # Once the game servant is obtained, get the remaining ETA from it while it is waiting for new players.
    global root, _w1, pending_time_remaining
    if pending_time_remaining > 0:
        _w1.update_time_remaining(pending_time_remaining)
        pending_time_remaining = int(game_servant.getRemainingPendingTime() / 1000)

        root.after(10, update_pending_frame)
    else:
        # After the pending frame is finished, close it.
        root.destroy()
        root.quit()
        
ready_time_remaining = None
round_time_remaining = None
results_time_remaining = None

def update_ready_time():
    # Wait for the ready timer

    global ready_time_remaining, game_servant, _w1, root, round_time_remaining
    if ready_time_remaining > 0:
        ready_time_remaining = int(game_servant.getRemainingReadyTime() / 1000)
        _w1.update_feedback_label_text(str(ready_time_remaining))
        root.after(10, update_ready_time)
    else:
        # Once the ready timer is finished, switch to a new callback method for the after method.
        _w1.update_feedback_label_text("Go!")
        _w1.set_button_status(True)
        random_letters = game_servant.getLetters()
        _w1.update_random_letters(random_letters)
        round_time_remaining = game_servant.getRemainingRoundTime()

        root.after(10, update_round_time)


def update_round_time():
    # Now do the round timer
    global game_servant, _w1, root, round_time_remaining
    if round_time_remaining > 0:
        round_time_remaining = int(game_servant.getRemainingRoundTime() / 1000)
        _w1.update_round_time(round_time_remaining)
        root.after(10, update_round_time)
    else:
        # Once the round is finished, close the frame.
        root.destroy()
        root.quit()


def update_results_time():
    global results_time_remaining, game_servant, _w1, root
    if results_time_remaining > 0:
        results_time_remaining = int(game_servant.getRemainingResultsTime() / 1000)
        root.after(10, update_results_time)
    else:
        root.destroy()
        root.quit()

game_menu_frame = None
left_game = None
player_id_global = None
def quit_game():
    global _w1, root, left_game, game_servant, player_id_global
    root.destroy()
    root.quit()
    left_game = True
    game_servant.leaveGame(player_id_global)
    mb.showinfo(title="Game quit", message="You have left the game")



def main(game_menu_frame_in=None, naming_context=None, game_menu_servant=None, player_id=None, *args):
    '''Main entry point for the application.'''
    global root, game_servant, pending_time_remaining, ready_time_remaining, round_time_remaining, results_time_remaining, game_menu_frame, left_game, player_id_global
    player_id_global = player_id
    left_game = False
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , quit_game)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    game_menu_frame = game_menu_frame_in

    # Try to join a pending game first; if no game can be found, create a new game and set to a new frame.
    gameId = None
    try:
        gameId = game_menu_servant.joinGame(player_id)
    except NoGameFoundException:
        gameId = game_menu_servant.createGame(player_id)

    _w1 = pending_game_frame.Toplevel1(_top1)


    # Once the frame has been set, obtain the game object using the game id as a reference.

    # Create a name to look up
    name = [CosNaming.NameComponent(str(gameId), "")]

    # Resolve the name to get the servant object reference
    obj = naming_context.resolve(name)
    game_servant = obj._narrow(wordy_idl.GameServant)

    pending_time_remaining = int(game_servant.getRemainingPendingTime() / 1000)
    root.after(10, update_pending_frame)
    root.mainloop()



    # Once the countdown is finished, check if there are any players who have joined.
    # If there are no players who have joined, inform the player with a dialog box
    # and exit out of the in game frame.
    player_count = game_servant.checkPlayerCount()
    if left_game:
        pass
    elif player_count <= 1:
        mb.showinfo(title="No players joined", message="No other players have joined the game")
        game_menu_frame.deiconify()
    # If more than 1 player has joined, switch to the in game frame
    else:
        while not game_servant.gameIsFinished():
            root = tk.Tk()
            root.protocol('WM_DELETE_WINDOW', quit_game)
            _top1 = root
            _w1 = in_game_frame.Toplevel1(_top1, game_servant, player_id)
            _w1.set_button_status(False)

            ready_time_remaining = int(game_servant.getRemainingReadyTime() / 1000)
            root.after(10, update_ready_time)
            root.mainloop()

            if left_game or game_servant.checkPlayerCount() <= 1:
                break

            # Once the round is finished, get the winner and show it with the results frame
            time.sleep(1)
            root = tk.Tk()
            root.protocol('WM_DELETE_WINDOW', quit_game)
            _top1 = root
            _w1 = results_frame.Toplevel1(_top1, game_servant.getUsersAndWins(), game_servant.getRoundWinnerName())

            results_time_remaining = int(game_servant.getRemainingResultsTime() / 1000)
            root.after(10, update_results_time)
            root.mainloop()
            if left_game:
                break

        if left_game:
            pass
        else:
            # Once the game is finished, show if the player won the game
            message = ""
            title = ""
            try:
                time.sleep(1)
                if game_servant.youAreWinner(player_id):
                    message = "Congratulations! You won!"
                    title = "Winner!"
                else:
                    message = "Sorry! You lost!"
                    title = "Defeat!"
            except NoWinnerException:
                message = "No other players remaining."
                title = "No more players"

            mb.showinfo(title=title, message=message)

    game_menu_frame_in.deiconify()



if __name__ == '__main__':
    in_game_frame.start_up()




